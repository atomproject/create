<link rel="import" href="../bower_components/polymer/polymer.html">

<script>
  Polymer.StateConverterBehavior = {
    // Also assumes the property `this.metadata`.
    properties: {
      templateCache: {
        type: Object,
        value: function() {
          return {};
        }
      }
    },

    getNewElementState: function(name, x, y) {
      var meta, states;

      if (_.isArray(name)) {
        states = name;
        meta = states.find(function(item) {
          return item.posX === x && item.posY === y;
        });
        name = meta.name;
      }
      else if (_.isObject(name)) {
        meta = name;

        return {
          posX: x, posY: y,
          name: meta.name,
          html: meta.html, innerHTML: meta.innerHTML,
          attributes: meta.attributes, property: meta.property,
          dataSources: {}
        };
      }
      else {
        meta = this.metadata[name];
      }

      return {
        name: name, posX: x, posY: y,
        html: meta.html, innerHTML: meta.innerHTML,
        attributes: _.cloneDeep(meta.attributes),
        property: _.cloneDeep(meta.property),
        dataSources: {}
      };
    },

    getStateFile: function(builderState, states) {
      var stateFile;

      if (!builderState || !states) {
        return;
      }

      if (!states.length) {
        throw new Error('No elements to download');
      }

      stateFile = {
        type: builderState.name,
        attributes: builderState.attributes,
        property: builderState.property,
        rows: this.getStateHierarchy(states)
      };

      return JSON.stringify(stateFile, null, 2);
    },

    getStateHierarchy: function(states) {
      var rows = [];

      states.forEach(function(state) {
        var row, column;

        if (!rows[state.posX]) {
          rows[state.posX] = [];
        }

        row = rows[state.posX];
        column = row[state.posY] = {};

        column.name = state.name;
        column.html = state.html;
        column.attributes = state.attributes;
        column.property = state.property;
        column.dataSources = state.dataSources;
      });

      return rows;
    },

    getDependencies: function(states) {
      var scriptImports = {}, linkImports = {};
      var bower = {}, bowerDev = {}, metadata = this.metadata;
      var components;

      function toArray(obj) {
        return Object.keys(obj)
          .map(function(key) {
            return obj[key];
          })
          .filter(function(val) {
            return val !== undefined || val !== null;
          });
      }

      function gatherImports(deps, type, imports) {
        deps
          .filter(function(dep) {
            return dep.type === type;
          })
          // save only unique imports
          .forEach(function(dep) {
            imports[dep.relPath] = dep;
          });
      }

      components = states
        .map(function(state) {
          return state.name;
        })
        // get unique names
        .filter(function(name, i, arr) {
          return arr.indexOf(name) === i;
        })
        .sort();

      components.forEach(function(name) {
        var dependencies = metadata[name].dependencies;

        dependencies.forEach(function(dep) {
          bower[dep.pkg] = dep;
        });

        gatherImports(dependencies, 'link', linkImports);
        gatherImports(dependencies, 'script', scriptImports);
      });

      return {
        bower: toArray(bower),
        bowerDev: toArray(bowerDev),
        linkImports: toArray(linkImports),
        scriptImports: toArray(scriptImports)
      };
    },

    getBowerFile: function(builderState, states) {
      var context = {};
      var polyfill = {
        pkg: 'webcomponentsjs',
        install: '^0.7.19',
        relPath: 'webcomponentsjs/webcomponents-lite.js',
        type: 'script'
      };

      if (!builderState || !states) {
        return;
      }

      context.dependencies = this.getDependencies(states);
      context.componentName = builderState.attributes.name;

      // `type` and `relPath` are not needed
      context.dependencies.bower.push({
        pkg: builderState.name,
        install: 'atomelements/' + builderState.name + '#^1.0.0'
      });

      if (builderState.isPage) {
        context.dependencies.bower.push(polyfill);
      } else {
        context.dependencies.bowerDev.push(polyfill);
      }

      return this.getFile('templates/bower.jst', context);
    },

    getDemoFile: function(builderState) {
      var context = {};

      if (!builderState) {
        return;
      }

      context.componentName = builderState.attributes.name;

      if (!builderState.isPage) {
        return this.getFile('templates/demo.jst', context);
      }

      return Promise.resolve();
    },

    getFile: function(templatePath, context) {
      var template = this.templateCache[templatePath];

      return Promise.resolve(template)
        .then(function(template) {
          if (!template) {
            return $.get(templatePath);
          }

          return template;
        })
        .then(function(template) {
          if (!_.isFunction(template)) {
            template = _.template(template);
            this.templateCache[templatePath] = template;
          }

          return template(context);
        }.bind(this));
    },

    getBuilderFile: function(builderState, states) {
      var context = {}, endTag, templatePath;

      if (!builderState || !states) {
        return;
      }

      context.rows = this.getStateHierarchy(states);
      context.dependencies = this.getDependencies(states);
      context.componentName = builderState.attributes.name;

      context.builderEndTag = endTag = '</' + builderState.name + '>';
      context.builderStartTag = builderState.html.replace(endTag, '');

      if (builderState.isPage) {
        context.pageName = context.componentName.replace('t-', '');
        templatePath = 'templates/page.jst';
      } else {
        templatePath = 'templates/component.jst';
      }

      return this.getFile(templatePath, context);
    }
  };
</script>
